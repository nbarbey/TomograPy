/*
  C Siddon algorithm and its python wrapper. It performs 3D conic projection
  and backprojection for tomography applications.
*/

/*============================================================================*/
/* Header */

#include "Python.h"
#include "arrayobject.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>

/* To avoid division by zero. */
#define INF 1000000. /* in solar radii*/
/* Dimension number of the problem. */
#define NDIM 3 /*number of dimensions*/

/* To allow for multiple data types through templating. */
#define CTYPE %(ctype)s

/* True if x is a NaN. */
#define isNaN(x) ((x) != (x))
/* Power of two. */
#define SQ(x) ((x) * (x))
/* Python array indexing. */
#define IND1(a, i) *((CTYPE *) PyArray_GETPTR1(a, i))
#define IND2(a, i) *((CTYPE *) PyArray_GETPTR2(a, i[0], i[1]))
#define IND3(a, i) *((CTYPE *) PyArray_GETPTR3(a, i[0], i[1], i[2]))
#define IND3t(a, i, j) *(CTYPE *)(a->data + i[0] * a->strides[0]	\
				  + i[1] * a->strides[1]		\
				  + i[2] * a->strides[2]		\
				  + j * a->strides[3])
#define IND4(a, i) *(CTYPE *)(a->data + i[0] * a->strides[0]	\
			      + i[1] * a->strides[1]		\
			      + i[2] * a->strides[2]		\
			      + i[3] * a->strides[3])

/*numpy 2.0 way :*/
/*
  #define IND3t(a, i, j) *((CTYPE *) PyArray_GETPTR4(a, i[0], i[1], i[2], j))
  #define IND4(a, i) *((CTYPE *) PyArray_GETPTR4(a, i[0], i[1], i[2], i[3]))
*/

/* Structures definitions */

/* define the detector parameters */
typedef struct
{
  /* size of a pixel in radians */
  CTYPE p1;
  CTYPE p2;
  /* size in pixels*/
  uint n1;
  uint n2;
  /* position of the sun center in pixels (can be a fraction of pixel) */
  CTYPE s1;
  CTYPE s2;
}detector;

/* define the position of the detector */
typedef struct
{
  /* spherical coordinates*/
  /* longitude in radians */
  CTYPE lon;
 /* latitude in radians */
  CTYPE lat;
 /* roll angle in radians */
  CTYPE rol;
  /* distance to center */
  CTYPE d;
  /* cartesian coordinates */
  CTYPE M[NDIM];
}orbit;

/* define the parameters of the "region of interest" of the object */
typedef struct
{
  /*size of the object cube */
  CTYPE d[NDIM];
  /* size of a pixel in physical dimensions. */
  CTYPE p[NDIM];
  /* size in pixels */
  uint n[NDIM];
  /*bounds of the volume */
  CTYPE min[NDIM];
  CTYPE max[NDIM];
}RoiO;

/* Functions declarations */

void init_C_siddon%(suffix)s();
static PyObject *call_siddon%(suffix)s(PyObject *self, PyObject *args);

/* Compute integration along the line of sight. */
inline void trace_ray(CTYPE[NDIM],
		      CTYPE[NDIM],
		      PyArrayObject*,
		      uint[NDIM],
		      PyArrayObject*,
		      RoiO*);

/* Perform computation that can be done outside of the line of sight loop. */
inline void initialize_raytracing(RoiO *,
				  CTYPE[NDIM],
				  CTYPE[NDIM],
				  CTYPE[NDIM],
				  CTYPE[NDIM],
				  CTYPE,
				  int[NDIM],
				  uint[NDIM],
				  CTYPE[NDIM]);


/* Check if line of sight goes through the map cube. */
inline void intersect_cube(RoiO * ,
			   CTYPE [NDIM],
			   CTYPE [NDIM],
			   CTYPE [NDIM],
			   CTYPE [NDIM],
			   CTYPE *,
			   CTYPE *);

/* Update voxel index and perform pj or bpj. */
inline void voxel(PyArrayObject*,
		  uint[NDIM],
		  PyArrayObject*,
		  uint[NDIM],
		  CTYPE[NDIM],
		  CTYPE *,
		  CTYPE[NDIM],
		  int[NDIM]);

/* projection / backprojection of a voxel. */
inline void pj(PyArrayObject*, uint[NDIM], PyArrayObject*, uint[NDIM], CTYPE);
inline void bpj(PyArrayObject*, uint[NDIM], PyArrayObject*, uint[NDIM], CTYPE);
/* projection / backprojection with temporal index */
inline void pjt(PyArrayObject*, uint[NDIM], PyArrayObject*, uint[NDIM], CTYPE);
inline void bpjt(PyArrayObject*, uint[NDIM], PyArrayObject*, uint[NDIM], CTYPE);
/* Check if voxel index is inside the cube. */
inline int in_cube(RoiO, uint[NDIM]);
/* Check if voxel index is outside a sphere of radius 1. */
inline int sun(CTYPE[NDIM], CTYPE[NDIM], CTYPE);
/* Returns always 1. (replace sun if no sun obsactle is required. */
inline int none(CTYPE[NDIM], CTYPE[NDIM], CTYPE);
/* Minimum or maximum of 3 values. */
inline CTYPE min3(CTYPE, CTYPE, CTYPE);
inline CTYPE max3(CTYPE, CTYPE, CTYPE);
/* Returns 1 if input is positive, -1 if negative and 0 if input equal 0. */
inline int sign(CTYPE);
/* Output 2 values after sorting 2 input values. */
inline void compare(CTYPE*, CTYPE*, CTYPE, CTYPE);
/* Compute a rotation matrix. */
inline void rotation_matrix(orbit, CTYPE [NDIM][NDIM]);
/* Define unit vector from spherical coordinates. */
inline void define_unit_vector(CTYPE, CTYPE, CTYPE[NDIM]);
/* Apply a rotation matrix to a vector */
inline void apply_rotation(CTYPE[NDIM][NDIM] , CTYPE[NDIM], CTYPE[NDIM]);
/* Comupte the distance from the map cube reference pixel (center). */
inline CTYPE distance_to_center(CTYPE[NDIM], CTYPE[NDIM], CTYPE);
/* Perform projection / backprojection of an image set. */
inline void Siddon(
	       PyArrayObject*,
	       uint,
	       PyArrayObject*,
	       orbit,
	       RoiO*,
	       detector
	       );

/*============================================================================*/
/* Functions code */

static PyMethodDef _C_siddon%(suffix)sMethods[] = {
  {"siddon", call_siddon%(suffix)s, METH_VARARGS},
  {NULL, NULL}     /* Sentinel - marks the end of this structure */
};

void init_C_siddon%(suffix)s()  {
  (void) Py_InitModule("_C_siddon%(suffix)s", _C_siddon%(suffix)sMethods);
  import_array();  // Must be present for NumPy.  Called first after above line.
  Py_Initialize();
}

static PyObject *call_siddon%(suffix)s(PyObject *self, PyObject *args)
{
  /* Input and output matrices to be extracted from args */
  PyArrayObject *data, *map;
  PyObject *header, *cube_header;
  orbit orbit;
  detector detector;
  RoiO RoiO;
  uint t;
  PyArrayObject *lon, *lat, *rol, *d, *xd, *yd, *zd;
  PyArrayObject *cdelt1, *cdelt2, *crpix1, *crpix2;
  PyObject *ocdelt1, *ocdelt2, *ocdelt3;
  PyObject *ocrpix1, *ocrpix2, *ocrpix3;
  CTYPE cube_crpix1, cube_crpix2, cube_crpix3;

  /*integers : dimension of the input and output array */
  uint nt, n1, n2, nx, ny, nz;

  /* Parse tuples separately since args will differ between C fcns */
  if (!PyArg_ParseTuple(args, "O!O!", &PyArray_Type, &data,
			&PyArray_Type, &map))
    return NULL;
  /*Raise errors if input matrix is missing*/
  if (NULL == data)
    return NULL;
  if (NULL == map)
    return NULL;
 
  /* Get data and map dimensions. */
  n1 = data->dimensions[0];
  n2 = data->dimensions[1];
  nt = data->dimensions[2];
  nx = map->dimensions[0];
  ny = map->dimensions[1];
  nz = map->dimensions[2];
  /* Get data header */
  header = PyObject_GetAttrString((PyObject*)data, "header");
  lon = (PyArrayObject*)PyDict_GetItemString(header, "LON");
  lat = (PyArrayObject*)PyDict_GetItemString(header, "LAT");
  rol = (PyArrayObject*)PyDict_GetItemString(header, "ROL");
  d = (PyArrayObject*)PyDict_GetItemString(header, "D");
  xd = (PyArrayObject*)PyDict_GetItemString(header, "XD");
  yd = (PyArrayObject*)PyDict_GetItemString(header, "YD");
  zd = (PyArrayObject*)PyDict_GetItemString(header, "ZD");
  cdelt1 = (PyArrayObject*)PyDict_GetItemString(header, "CDELT1");
  cdelt2 = (PyArrayObject*)PyDict_GetItemString(header, "CDELT2");
  crpix1 = (PyArrayObject*)PyDict_GetItemString(header, "CRPIX1");
  crpix2 = (PyArrayObject*)PyDict_GetItemString(header, "CRPIX2");
  /* Region of interest of the object */
  cube_header = PyObject_GetAttrString((PyObject*)map, "header");
  RoiO.n[0] = nx;
  RoiO.n[1] = ny;
  RoiO.n[2] = nz;
  ocdelt1 = (PyObject*)PyDict_GetItemString(cube_header, "CDELT1");
  ocdelt2 = (PyObject*)PyDict_GetItemString(cube_header, "CDELT2");
  ocdelt3 = (PyObject*)PyDict_GetItemString(cube_header, "CDELT3");
  RoiO.p[0] = (CTYPE)PyFloat_AsDouble(ocdelt1);
  RoiO.p[1] = (CTYPE)PyFloat_AsDouble(ocdelt2);
  RoiO.p[2] = (CTYPE)PyFloat_AsDouble(ocdelt3);
  RoiO.d[0] = RoiO.p[0] * nx;
  RoiO.d[1] = RoiO.p[1] * ny;
  RoiO.d[2] = RoiO.p[2] * nz;
  ocrpix1 = (PyObject*)PyDict_GetItemString(cube_header, "CRPIX1");
  ocrpix2 = (PyObject*)PyDict_GetItemString(cube_header, "CRPIX2");
  ocrpix3 = (PyObject*)PyDict_GetItemString(cube_header, "CRPIX3");
  cube_crpix1 = (CTYPE)PyFloat_AsDouble(ocrpix1);
  cube_crpix2 = (CTYPE)PyFloat_AsDouble(ocrpix2);
  cube_crpix3 = (CTYPE)PyFloat_AsDouble(ocrpix3);
  RoiO.min[0] = - cube_crpix1 * RoiO.p[0];
  RoiO.min[1] = - cube_crpix2 * RoiO.p[1];
  RoiO.min[2] = - cube_crpix3 * RoiO.p[2];
  RoiO.max[0] = RoiO.min[0] + RoiO.d[0];
  RoiO.max[1] = RoiO.min[1] + RoiO.d[1];
  RoiO.max[2] = RoiO.min[2] + RoiO.d[2];
  /* Loop on the time / image dimension */
  #pragma omp parallel default(shared) private(t, orbit, detector)
  #pragma omp for
  for(t = 0 ; t < nt ; t++){
    /* define orbit of current image */
    orbit.lon = IND1(lon, t);
    orbit.lat = IND1(lat, t);
    orbit.rol = IND1(rol, t);
    orbit.d = IND1(d, t);
    orbit.M[0] = IND1(xd, t);
    orbit.M[1] = IND1(yd, t);
    orbit.M[2] = IND1(zd, t);
    /* define the detector of current image */
    detector.p1 = IND1(cdelt1, t);
    detector.p2 = IND1(cdelt2, t);
    detector.s1 = IND1(crpix1, t);
    detector.s2 = IND1(crpix2, t);
    detector.n1 = n1;
    detector.n2 = n2;
    /* Siddon for each time index */
    Siddon(data, t, map, orbit, &RoiO, detector);
  }
  Py_RETURN_NONE;
}

void Siddon(PyArrayObject * data,
	   uint t,
	   PyArrayObject * cube,
	   orbit orbit,
	   RoiO * pRoiO,
	   detector detector)
{
  /* declarations */
  /* loop incremented integers*/
  uint id[NDIM];
  /* to store constants defining the ray direction */
  /* lambda : latitude, longitude */
  CTYPE lambda, gamma;
  /* normalized direction vector in image referentiel */
  CTYPE u2[NDIM];
  /* in solar referentiel */
  CTYPE u0[NDIM];
  /* rotation matrix from image to solar referentiel */
  CTYPE R[NDIM][NDIM];

  id[2] = t;
  /* the rotation matrix does not change for one image */
  rotation_matrix(orbit, R);
  /* loops on angles (detectors pixels) */
  for(id[0] = 0 ; id[0] < detector.n1 ; id[0]++)
  {
    gamma = (id[0] - detector.s1) * detector.p1;
    for(id[1] = 0 ; id[1] < detector.n2 ; id[1]++)
    {
      /* skip computation if the value is a NaN */
      if((isNaN(IND3(data, id)) == 0))
      {
	lambda = (id[1] - detector.s2) * detector.p2;
	define_unit_vector(lambda, gamma, u2);
	apply_rotation(R, u2, u0);
	trace_ray(orbit.M, u0, data, id, cube, pRoiO);
      }
    }
  }
}

void trace_ray(CTYPE M[3],
	       CTYPE u0[3],
	       PyArrayObject * data,
	       uint id[3],
	       PyArrayObject * cube,
	       RoiO * pRoiO)
{
  RoiO RoiO = * pRoiO;
  /* distance of the current voxel to the detector   */
  CTYPE ac; 
  /* array containing the distances to the 6 faces of the volume*/
  CTYPE a1[NDIM];
  /* minimum of the distance array and it subscript */
  CTYPE amin=0;
  CTYPE amax=0;
  /* subscripts of the current voxel */
  uint iv[NDIM];
  /* distances to the next intersection with a x,y or z constant
     plan of the grid */
  CTYPE p[NDIM];
  /* current distances to the next intersection with a x,y or z 
     constant plan of the grid */
  CTYPE D[NDIM];
  /* to discriminate between increasing and decreasing of voxel 
     subscripts*/
  int update[NDIM];

  intersect_cube(pRoiO, M, u0, p, a1, &amin, &amax);
  /* otherwise the ray does not go through the cube */
  if(amin < amax)
  {
    /* loop initilization */
    initialize_raytracing(pRoiO, M, u0, p, a1, amin, update, iv, D);
    ac = amin;
    /* check if still into the cube and did not reached the obstacles */
    while(in_cube(RoiO, iv) && %(obstacle)s(M, u0, ac))
    {
      voxel(data, id, cube, iv, D, &ac, p, update);
    }
  }
}

void initialize_raytracing(RoiO *pRoiO,
			   CTYPE M[NDIM],
			   CTYPE u0[NDIM],
			   CTYPE p[NDIM],
			   CTYPE a1[NDIM],
			   CTYPE amin,
			   int update[NDIM],
			   uint iv[NDIM],
			   CTYPE D[NDIM])
{
  RoiO RoiO = * pRoiO;
  uint k;
  /* coordinates of the initial and final points */
  CTYPE e[NDIM];
  uint next[NDIM];
  /*loop on each dimension*/
  for(k = 0 ; k < NDIM ; k ++)
  {
    /* initial and final points in cartesian coordinates */
    e[k] = M[k] + amin * u0[k];
    update[k] = sign(u0[k]);
    /*  initial intersection*/
    iv[k] = (uint)( (e[k] - RoiO.min[k]) / RoiO.p[k]);
    /* initial voxel of each kind */
    iv[k] -= (uint)( (e[k] - RoiO.min[k]) / RoiO.d[k]);
    /* next intersection of each kind */
    if(update[k] == 1)
      next[k] = iv[k] + 1;
    else if(update[k] == -1)
      next[k] = iv[k];
    else
      next[k] = INF * RoiO.n[k];
    D[k] = next[k] * p[k] + a1[k] - amin;
  }
}

void intersect_cube(RoiO * pRoiO,
		    CTYPE M[NDIM],
		    CTYPE u0[NDIM],
		    CTYPE p[NDIM],
		    CTYPE a1[NDIM],
		    CTYPE * pamin,
		    CTYPE * pamax)
{
  RoiO RoiO = * pRoiO;
  uint k;
  CTYPE an[NDIM];
  /* intersections avec les differentes faces */
  CTYPE Imin[NDIM], Imax[NDIM];
  /**/
  CTYPE u0inv[NDIM];

  /* impact point determination */
  for(k = 0 ; k < NDIM ; k++)
  {
    if(u0[k] == 0){
      p[k] = INF;
      a1[k] = - INF;
      an[k] = INF;}
    else{
      u0inv[k] = 1 / u0[k];
      p[k] = RoiO.p[k] * u0inv[k];
      a1[k] = (RoiO.min[k] - M[k]) * u0inv[k];
      an[k] = (RoiO.max[k] - M[k]) * u0inv[k];}

    compare(&Imin[k], &Imax[k], a1[k], an[k]);
  }
  *pamin = max3(Imin[0], Imin[1], Imin[2]);
  *pamax = min3(Imax[0], Imax[1], Imax[2]);
}

void voxel(PyArrayObject * data,
	   uint id[NDIM],
	   PyArrayObject * cube,
	   uint iv[NDIM],
	   CTYPE D[NDIM],
	   CTYPE * pac,
	   CTYPE p[NDIM],
	   int update[NDIM])
{
  /* check along which dimension is the current intersection */
  if((D[0] <= D[1]) && (D[0] <= D[2]))
  {
    *pac += D[0];
    /* projection*/
    %(pj)s(data, id, cube, iv, D[0]);
    /* update voxel subscript */
    iv[0] += update[0];
    /* update distances to next intersections*/
    D[1] -= D[0];
    D[2] -= D[0];
    D[0] = fabs(p[0]);
  }
  else if((D[1] < D[0]) && (D[1] <= D[2]))
  {
    *pac += D[1];
    /* projection */
    %(pj)s(data, id, cube, iv, D[1]);
    /* update voxel subscript */
    iv[1] += update[1];
    /* update distances to next intersections*/
    D[0] -= D[1];
    D[2] -= D[1];
    D[1] = fabs(p[1]);
  }
  else if((D[2] < D[0]) && (D[2] < D[1]))
  {
    *pac += D[2];
    /* projection */
    %(pj)s(data, id, cube, iv, D[2]);
    /* update voxel subscript */
    iv[2] += update[2];
    /* update distances to next intersections*/
    D[0] -= D[2];
    D[1] -= D[2];
    D[2] = fabs(p[2]);
  }
}

/* projection update */
void pj(PyArrayObject * data, uint id[NDIM], PyArrayObject * cube,
	uint iv[NDIM], CTYPE d)
{
#pragma omp atomic
  IND3(data, id) += d * IND3(cube, iv);
}

/* backprojection update*/
void bpj(PyArrayObject * data, uint id[NDIM], PyArrayObject * cube,
	 uint iv[NDIM], CTYPE d)
{
#pragma omp atomic
  IND3(cube, iv) += d * IND3(data, id);
}

/* projection with time */
void pjt(PyArrayObject * data, uint id[NDIM], PyArrayObject * cube,
	 uint iv[NDIM], CTYPE d)
{
#pragma omp atomic
  IND3(data, id) += d * IND3t(cube, iv, id[2]);
}

/* backprojection with time*/
void bpjt(PyArrayObject * data, uint id[NDIM], PyArrayObject * cube,
	  uint iv[NDIM], CTYPE d)
{
#pragma omp atomic
  IND3t(cube, iv, id[2]) += d * IND3(data, id);
}


/* check if still in map cube */
int in_cube(RoiO RoiO, uint iv[NDIM])
{
  return (iv[0] >= 0 && iv[0] < RoiO.n[0] 
	  && iv[1] >= 0 && iv[1] < RoiO.n[1]
	  && iv[2] >= 0 && iv[2] < RoiO.n[2]);
}

/* check if the ray has reached the sphere of radius 1 */
int sun(CTYPE M[NDIM], CTYPE u0[NDIM], CTYPE ac)
{
  CTYPE d;
  d = distance_to_center(M, u0, ac);
  return d > 1;
}

/* always true : replace sun if no sun obstacle is desired */
int none(CTYPE M[NDIM], CTYPE u0[NDIM], CTYPE ac)
{
  return 1;
}

CTYPE min3(CTYPE x, CTYPE y, CTYPE z)
{
  if((x < y)&(x < z))
    return x;
  else if ((y < x)&(y < z))
    return y;
  else
    return z;
}

CTYPE max3(CTYPE x, CTYPE y, CTYPE z)
{
  if((x > y)&(x > z))
    return x;
  else if ((y > x)&(y > z))
    return y;
  else
    return z;
}

int sign(CTYPE x)
{
  if (x>0)
    return 1;
  else if(x<0)
    return -1;
  else
    return 0;
}

void compare(CTYPE * pumin, CTYPE * pumax, CTYPE u1, CTYPE u2)
{
  if (u1 > u2)
  {
    (*pumin) = u2;
    (*pumax) = u1;
  }
  else
  {
    (*pumin) = u1;
    (*pumax) = u2;    
  }
}

void rotation_matrix(orbit orbit, CTYPE R[NDIM][NDIM])
{
  /* to define the rotation matrix*/
  CTYPE cosln,sinln,coslt,sinlt,cosrl,sinrl;

  cosln = cos(orbit.lon);
  sinln = sin(orbit.lon);
  coslt = cos(orbit.lat);
  sinlt = sin(orbit.lat);
  cosrl = cos(orbit.rol);
  sinrl = sin(orbit.rol);

  R[0][0] = - cosln * coslt;
  R[0][1] = - sinln * cosrl - cosln * sinlt * sinrl;
  R[0][2] =   sinln * sinrl - cosln * sinlt * cosrl;
  R[1][0] = - sinln * coslt;
  R[1][1] =   cosln * cosrl - sinln * sinlt * sinrl;
  R[1][2] = - cosln * sinrl - sinln * sinlt * cosrl;
  R[2][0] = - sinlt;
  R[2][1] =   coslt * sinrl;
  R[2][2] =   coslt * cosrl;
}

void define_unit_vector(CTYPE lambda, CTYPE gamma, CTYPE u2[NDIM])
{
  u2[0] = cos(lambda) * cos(gamma);
  u2[1] = cos(lambda) * sin(gamma);
  u2[2] = sin(lambda);
}

void apply_rotation(CTYPE R[NDIM][NDIM], CTYPE u2[NDIM], CTYPE u0[NDIM])
{
  u0[0] = R[0][0] * u2[0] + R[0][1] * u2[1] + R[0][2] * u2[2];
  u0[1] = R[1][0] * u2[0] + R[1][1] * u2[1] + R[1][2] * u2[2];
  u0[2] = R[2][0] * u2[0] + R[2][1] * u2[1] + R[2][2] * u2[2];
}

CTYPE distance_to_center(CTYPE M[NDIM], CTYPE u0[NDIM], CTYPE ac)
{
  CTYPE d;
  d = SQ(M[0] + ac * u0[0]);
  d += SQ(M[1] + ac * u0[1]);
  d += SQ(M[2] + ac * u0[2]);
  return d;
}
